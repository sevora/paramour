/*
 * Paramour 
 * A chemistry and compatibility calculator
 * using steganized images generated by the
 * web-application modified in accordance
 * to survey answers as inputs
 */
require('dotenv').config();

/*
 * Express server configuration
 * Pug is used as view engine
 * Static assets are found inside 
 * assets directory and served from '/'
 */
const express = require('express');

const app = express();

app.set('view engine', 'pug');

app.use( express.static('assets') );

/*
 * Body parser middleware
 * is for parsing POST request
 * encoded data
 */
const bodyParser = require('body-parser');

app.use( bodyParser.urlencoded({ extended: false }) );

app.use( bodyParser.json() );

/*
 * This will allow the feature of
 * sessions and saving a UID to the client
 * that can access specific data on the server
 * In this case, their previous result
 */
const session = require('express-session');
const MemoryStore = require('memorystore')(session);

app.use( session({ 

    secret: process.env.SECRET,

    cookie: { maxAge: Number(process.env.MAX_AGE) },
     
    store: new MemoryStore({
      checkPeriod: 86400000 // prune expired entries every 24h
    }),

    resave: false,

    saveUninitialized: true,

}) );

const secure = require('express-force-https');

app.use(secure);
/*
 * QR Code Generation
 * and scanning. To prevent the code
 * from getting too large, jsonpack is utilized
 */
const QRCode = require('qrcode'); // qr code generator

const Jimp = require('jimp'); // image reader

const jsQR = require('jsqr'); // qr code scanner

//
const schema = require('./schema');

const csv = require('csvtojson');

/*
 * For server-side validation, if requirements aren't met
 * server would serve 404 page
 */
const { body:bodyValidation, validationResult } = require('express-validator');

/*
 * This middleware is for the file upload
 */
const fileUpload = require('express-fileupload');

app.use( fileUpload({ limits: { fileSize: 5 * 1024 * 1024 } }) );

/*
 * Index page rendering
 * simply serve it
 */
app.get(['/', '/index'], function(request, response) {
    
    response.render('index');

});

/*
 * This logic is outside the route to prevent recalculation
 * and optimize the speed of the server even by a little.
 * The data is served on the /new route
 */
const chemistry = require('./chemistry.json');

const hobbies = {}; // dictionary where the keys are the hobby names and their value is their classification

for (let category in chemistry.hobbies) {
    
    for (let [index, hobby] of chemistry.hobbies[category].entries()) {

        hobbies[hobby] = `${category}`; // extra index to make the value unique

    }

}

// did not bother shuffling the list cause it is obvious anyways
const intellect = {};

for (let type in chemistry.intellect) {

    for (let [index, question] of chemistry.intellect[type].entries()) { 

        intellect[question] = `intellect-${type}-${index}`

    }
}

function shuffle(array) {

    let currentIndex = array.length;

    let temporaryValue;

    let randomIndex;

    while (0 !== currentIndex) {

        randomIndex = Math.floor(Math.random() * currentIndex);
        
        currentIndex -= 1;

        temporaryValue = array[currentIndex];

        array[currentIndex] = array[randomIndex];

        array[randomIndex] = temporaryValue;

    }

    return array;
}

// Shuffle the MBTI questions cause why not
const mbti = require('./mbti.json').questions;

const mbtiShuffled = {};

const mbtiKeysShuffled = shuffle( Object.keys(mbti) );

for (let key of mbtiKeysShuffled) { mbtiShuffled[key] = mbti[key]; }

app.get('/new', function(request, response) {

    response.render('new', { hobbies, values: chemistry.values, intellect, mbti: mbtiShuffled });

});

// Number of total questions
// 2 for the name and codename, 1 for the hobbies
// everything else is automatic
const totalQuestionsLength = 2 + 1 + chemistry.values.length + Object.keys(intellect).length + Object.keys(mbtiShuffled).length;

/*
 * This uses the saved image from the server temporarily via sessions for the client
 * especially when the client reloads the page
 */
app.get('/generate', function(request, response) {

    const { previousQRCode, previousCodeName } = request.session;

    if (previousQRCode && previousCodeName) {

        response.render('generate', { qrCode: previousQRCode, codename: previousCodeName });

    } else {

        response.render('404');

    }

});

/*
 *
 */
app.post('/generate', [

    bodyValidation('fullname').isLength({ min: 1, max: 24 }).trim().escape(),

    bodyValidation('codename').isLength({ min: 1, max: 24 }).trim(),

], async function(request, response) {

    const { body } = request;

    const errors = validationResult(request);

    if ( Object.keys(body).length != totalQuestionsLength || body.hobbies.length > 15 || !errors.isEmpty()) return response.render('404');

    const data = schema.getSchema();   

    data.fullname = body.fullname;

    data.codename = body.codename;
    /*
     * The next part is basically parsing the form and adding that to
     * the data object properly.
     */
    for (let hobby of body.hobbies) {
        
        for (let category in data.hobbies) {

            if ( hobby.includes(category) ) {
                 
                data.hobbiesComplete.push( hobby.replace(category + '-', '') );

                data.hobbies[category]++;

            }

        }

    }

    // used to parse values, intellect, and mbti due to their nature
    for (let requestKey in body) {

        if ( requestKey.includes('values') ) data.values.push(body[requestKey]);

        if ( requestKey.includes('intellect') ) {

            for (let intellect in data.intellect) {

               if ( requestKey.includes(intellect) ) {

                   data.intellect[intellect] += parseInt(body[requestKey]);
               }

            }

        }

        if ( requestKey.includes('mbti') ) {
            
            for (let trait in data.mbti) {

                if (trait == body[requestKey]) data.mbti[trait]++;

            }
        }
    }

    // this adds the codename of the user to the generated image
    QRCode.toDataURL(schema.compressSchema(data), { margin: 4, type: 'image/jpeg', errorCorrectionLevel: 'H' }, function(error, url) {
        
        if (error) return console.error(error);
        
        request.session.previousQRCode = url;

        request.session.previousCodeName = data.codename;

        response.render('generate', { qrCode: url, codename: data.codename });

    });


});

app.get('/match', function(request, response) { response.render('match'); });

// this is for sorting a dictionary with any key and value as an integer
function sortDictionary(dictionary) {

    return Object.entries(dictionary).sort((first, second) => second[1] - first[1]).map(element => element[0]);

}

async function scanImageBuffer(buffer) {

    const image = await Jimp.read(buffer);

    return jsQR(image.bitmap.data, image.bitmap.width, image.bitmap.height).data;

}

function getMaxDistanceOfTwoArrays(length) {

    let result = 0;

    for (let index = 0; index < length; index++) {
        
        result += Math.abs(index - (length - index) );

    }

    return result;
}

function getMBTIPersonality(mbti) {

    const keys = { 'introverted': 'I', 'extraverted': 'E', 'intuition': 'N', 'sensation': 'S', 'thinking': 'T', 'feeling': 'F', 'judging': 'J', 'perceiving': 'P' }

    const pairs = [
        
        ['introverted', 'extraverted'],

        ['intuition', 'sensation'],
        
        ['thinking', 'feeling'],

        ['judging', 'perceiving']

    ];

    let result = '';

    for (let pair of pairs) {

        let traitOne = pair[0];

        let traitTwo = pair[1];

        if (mbti[traitOne] > mbti[traitTwo]) {

            result += keys[traitOne];

        } else {

            result += keys[traitTwo];
        } 

    }

    return result;
}

/*
 *
 */
app.get('/results', function(request, response) {

    const { previousResult } = request.session;

    if (previousResult) {

        response.render('results', previousResult);

    } else {

        response.redirect('/match');

    }

});

/*
 * Route where the QR Codes are read and results are computed
 */
app.post('/results', async function(request, response) {

    if (!request.files['partner one'] || !request.files['partner two']) return response.render('404');

    const dataOne = await scanImageBuffer(request.files['partner one'].data);
  
    const dataTwo = await scanImageBuffer(request.files['partner two'].data);

    if (!dataOne || !dataTwo || !schema.isValidSchema(dataOne) || !schema.isValidSchema(dataTwo)) return response.render('404');

    const partnerOne = schema.decompressSchema(dataOne);

    const partnerTwo = schema.decompressSchema(dataTwo);

    /*
     * Compute the hobby score based
     * on how similar the hobbies both partners have
     * contributes to 20% of 50%
     */
    const partnerOneHobbyRank = sortDictionary(partnerOne.hobbies);

    const partnerTwoHobbyRank = sortDictionary(partnerTwo.hobbies);

    const sampleSchema = schema.getSchema();

    let hobbyScore = 0;

    // this loop makes the hobbyScore the distance based on the ranking of each hobby category from the partners
    for (let hobby in sampleSchema.hobbies) {

        hobbyScore += Math.abs( partnerOneHobbyRank.indexOf(hobby) - partnerTwoHobbyRank.indexOf(hobby) );

    }

    // subtract the same length of how many hobbies that are exactly the same from the partners
    hobbyScore -= partnerOne.hobbiesComplete.filter( value => partnerTwo.hobbiesComplete.includes(value) ).length;

    // turn the hobby score into a rate ranging from 0 to 1
    hobbyScore = hobbyScore > 0 ? 1 - hobbyScore /getMaxDistanceOfTwoArrays(Object.keys(sampleSchema.hobbies).length) : 1;

    /*
     * The value score is based off of the ratio
     * of how many values are alike and not alike
     * that means if the partners have the same number of like and unlike 
     * values then they have a good value score
     * Conributes to 40% of 50%
     */
    let valueScore = [0, 0];

    for (let index = 0; index < chemistry.values.length; index++) {
        
        if (partnerOne.values[index] == partnerTwo.values[index]) {

            valueScore[0]++;

            continue;
        }

        valueScore[1]++;

    }

    valueScore = valueScore.sort((a, b) => a - b);

    valueScore = valueScore[0] != 0 || valueScore[1] !=  0 ? valueScore[0] / valueScore[1] : 0;

    /*
     * Compute the intellect score based on how
     * similar the intellect is, contributes to 40% of 50%
     */

    const partnerOneIntellectRank = sortDictionary(partnerOne.intellect);

    const partnerTwoIntellectRank = sortDictionary(partnerTwo.intellect);

    let intellectScore = 0;

    // this loop makes the intellectScore the distance based on the ranking of each intellect type from the partners
    for (let intellect in sampleSchema.intellect) {

        intellectScore += Math.abs( partnerOneIntellectRank.indexOf(intellect) - partnerTwoIntellectRank.indexOf(intellect) );

    }

    // turn the intellectScore into a rate ranging from 0 to 1
    intellectScore = intellectScore > 0 ? 1 - intellectScore /getMaxDistanceOfTwoArrays(Object.keys(sampleSchema.intellect).length) : 1;

    const compatibilityTableJSON = await csv().fromFile('./compatibility.csv');

    const partnerOneMBTI = getMBTIPersonality(partnerOne.mbti);

    const partnerTwoMBTI = getMBTIPersonality(partnerTwo.mbti);

    let mbtiScore = 0;

    for (let column of compatibilityTableJSON) {

        if (column.field1 == partnerOneMBTI) mbtiScore = column[partnerTwoMBTI];
    } 

    mbtiScore = mbtiScore / 5;

    const chemistryScore = (hobbyScore * 0.2 + valueScore * 0.4 + intellectScore * 0.4);

    const finalScore = Math.round( (chemistryScore * 0.5 + mbtiScore * 0.5) * 100);

    const summaryOfResults = { 

        chemistryScore: Math.round(chemistryScore * 100),

        mbtiScore: Math.round(mbtiScore * 100),

        finalScore, 

        nameOne: partnerOne.fullname, 

        nameTwo: partnerTwo.fullname, 

        codeOne: partnerOne.codename, 

        codeTwo: partnerTwo.codename 

    }

    request.session.previousResult = summaryOfResults

    response.render('results', summaryOfResults);

});

/*
 * 404 route, basically catches everything that doesn't have a page
 */
app.all('*', function(request, response) { response.render('404'); });

app.listen(process.env.PORT || 80, function() { console.log('server started on specified port'); });
